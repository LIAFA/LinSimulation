% Suha's Proposal
\documentclass{article}


\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{arydshln}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{color}

\usepackage{amsfonts}
\usepackage{xspace}
\usepackage{latexsym}
\usepackage{wasysym} % causing problems with llncs's bold vectors
\usepackage{stmaryrd}
\usepackage{alltt}
\usepackage{mathpartir}
\usepackage[ligature,reserved,inference]{semantic}
\usepackage[lined]{algorithm2e}
\def\ttat{\mtt{@}} % the at package clobbers this
\usepackage{at}
\usepackage{alltt}


%\usepackage[numbers]{natbib}

%\input macros

\newtheorem{dfn}{Definition}
\newtheorem{lem}{Lemma}

\title{Existence of Forward Simulations for Particular Data Structures}
\begin{document}
\maketitle
\input{prelim}
\input{queue}

\section{Existence of Forward Simulations for Stack Implementations that have Fixed Pop Linearization Points}
\input{commit}
First, we describe the TS-Stack algorithm:
\begin{lstlisting}
struct Node{
  int data;
  int ts;
  Node* next;
  boolean taken;
};
Node* pools[maxThreads];
int TS = 0;   

void push(int x) {
  Node* n = new Node(x,MAX_INT,
                        null,false);
  n->next = pools[myTID];
  pools[myTID] = n;
  int i = TS++;
  n->ts = i;
}
int pop() {
 boolean success = false;
 int maxTS = -1;
 Node* youngest = null;
 while ( !success ) {
   maxTS = -1; youngest = null;
   for(int i=0; i<maxThreads; i++){
     Node* n = pools[i];
     while (n->taken && n->next != n)
       n = n->next;
     if(maxTS < n->ts) {
       maxTS = n->ts; youngest = n;
     }
   }
   if (youngest != null)
     success=CAS(youngest->taken,
                       false,true);
 }
 return youngest->data;
}
\end{lstlisting}
Then, we begin to obtain the LTS ($TSS$) of TS Stack from the algorithm by defining control points and the actions among these control points as seen in Figure X \textcolor{red}{Flow diagram is referenced here}. To simplify the proof, we take the initializations of some local variables together as atomic.

States of the TS-Stack contains the global variables and local variables as fields. Global variables are just elements of their domains and local variables are maps from operation identifiers to their domains. We say $i_q(k)$ for referencing the value of local variable $i$ of operation $k$ in state $q$. There is only one special local variable called $myTID$. Its value is unique to each pending operation in a state i.e., concurrent operations cannot have the same $myTID$ value. TS-Stack states also contains sets $O_a, O_r \in \mathbb{O}$ which are operation identifier sets of push and pops respectively, and the control point function $cp$ which is a map from operation identifiers to the control points set that are presented in the flow diagram Figure X  \textcolor{red}{Flow diagram is referenced here}. Transition relation of the TS-STack is presented in Figure~\ref{fig:transitions:TSSPush} (push rules) and Figure~\ref{fig:transitions:TSSPop} (pop rules).
Next, we show that the linearizability of TS Stack.

\begin{figure} [t]
{\scriptsize
  \centering
  \begin{mathpar}
    \inferrule[call-push]{
      k\not\in dom(cp) \\ 
      d\neq {\tt null}
    }{
      ..., O_a, x, cp,...
      \xrightarrow{inv(push,d,k)} 
     ..., O_a\cup\{k\}, x[k \mapsto d], cp[k \mapsto A_1], ...
    }\hspace{5mm}

    \inferrule[push1]{
      cp(k) = A_1 \\ 
      *n' = (x(k),\texttt{MAX\_INT}, \texttt{null}, \texttt{false})
    }{
      ..., n, cp,...
      \xrightarrow{push1(k)} 
     ..., n[k \mapsto n'], cp[k \mapsto A_2], ...
    }\hspace{5mm}
    
  
  \inferrule[push2]{
      cp(k) = A_2 
    }{
      ..., pools, cp,...
      \xrightarrow{push2(k)} 
     ..., pools[myTid(k) \mapsto n(k)], cp[k \mapsto A_3], ...
    }\hspace{5mm}
    
      \inferrule[push3]{
      cp(k) = A_3 
    }{
      ..., i, TS, cp,...
      \xrightarrow{push3(k)} 
     ..., i[k \mapsto TS], TS+1, cp[k \mapsto A_4], ...
    }\hspace{5mm}
    
   \inferrule[push4]{
      cp(k) = A_4 \\
      n'(k) = n(k)[ts \mapsto i(k)] \\
      \forall k'. cp(k') = A_6 \implies i(k') < i(k)
    }{
      ..., n, cp,...
      \xrightarrow{push4(k)} 
     ..., n[k \mapsto n'(k)], cp[k \mapsto A_5], ...
    }\hspace{5mm}
    
   \inferrule[ret-push]{
      cp(k) = A_5 
    }{
      ...,cp,...
      \xrightarrow{ret(push,k)} 
     ...,cp[k \mapsto A_6], ...
    }\hspace{5mm}
    
      \end{mathpar}
  }
 \vspace{-5mm}
  \caption{The push derivation rules of $TSS$. We only mention the state components that are modified. Unmentioned state components have the names in the algorithm in the prestate. $*n = (a,b,c,d)$ is shorthand for $n->data = a$, $n->ts = b$, ... $n' = n[ts \mapsto expr]$ is short for $n'->ts = expr$ and all the other fields of $n$ and $n'$ are the same.
  }
  \label{fig:transitions:TSSPush}
\vspace{-6mm}
\end{figure}

\begin{figure} [t]
{\scriptsize
  \centering
  \begin{mathpar}
    \inferrule[call-push]{
      k\not\in dom(cp) \\ 
      d\neq {\tt null}
    }{
      ..., O_a, x, cp,...
      \xrightarrow{inv(push,d,k)} 
     ..., O_a\cup\{k\}, x[k \mapsto d], cp[k \mapsto A_1], ...
    }\hspace{5mm}

    
      \end{mathpar}
  }
 \vspace{-5mm}
  \caption{The pop derivation rules of $TSS$. We only mention the state components that are modified. Unmentioned state components have the names in the algorithm in the prestate. $*n = (a,b,c,d)$ is shorthand for $n->data = a$, $n->ts = b$, ... $n' = n[ts \mapsto expr]$ is short for $n'->ts = expr$ and all the other fields of $n$ and $n'$ are the same.
  }
  \label{fig:transitions:TSSPop}
\vspace{-6mm}
\end{figure}

\begin{lem}
$TSS$ is a Com(pop)- refinement of $AbsS$. 
\end{lem}
\begin{proof}
Since $AbsS$ is deterministic with respect to $C \cup R \cup Com(pop)$, there exists a Com(pop) forward simulation from $TSS$ to $AbsS$ iff $TSS$ is a Com(pop)-refinement of $AbsS$. Hence, we define the relation $fs$ and show that it is a Com(pop)-forward simulation relation.

Let us make some clarifications before defining the relation. In order not to confuse nodes in TS Stack and nodes in $AbsS$, we call nodes of $AbsS$ as vertices from now on. We also define ordering relation (called traverse order) among the operations in a state of $TS$. It basically reflects the traverse order of pop operations. For two push operations $m,n \in O_a$ is state $s$ we say that $m <^{tr}_s n$ iff either $myTid(m) < myTid(n)$ or $myTid(m) = myTid(n)$ and $n_s(n)$ is reachable from $n_s(m)$ using next pointers. $\geq^{tr}$ is obtained from $<^{tr}$ in the usual way.

The relation $fs \subseteq Q_C \rightarrow Q_{AbsS}$ contains $(s,t)$ iff the following are satisfied:
\begin{itemize}
\item[\emph{Nodes}] $k \in O_t$ iff $k$ is a push operation in $s$ ($k \in O_a$) such that either it has not inserted its node to the pool yet ( $cp_s(k) = A_i$ and $i<3$) or its node is not taken by a pop ($cp_s(k) = A_i$, $i\geq 3$ and $n_s(k)->taken = false$). 
\item[\emph{Pend/Comp}] A vertex $k \in O_t$ is pending ($\ell_t(k) = (d, \texttt{PEND})$) iff $k$ satisfies the previous condition, $x_s(k) = d$ and it is not completed in $s$ ($cp_s(k) = A_i$ and $i<6$). Similarly, this vertex is completed ($\ell_t(k) = (d, \texttt{COMP})$) iff $k$ satisfies the previous condition, $x_s(k) = d$ and it is completed in $s$ ($cp_s(k) = A_6$). Pending vertices are maximal with respect to $<_t$ i.e., if $k \in O_t$ is a pending vertex, then for all $k' \in O_t$ $k \nless_t k'$.
\item[\emph{TSOrder}] If a node has a smaller timestamp than the other node in $s$, the operations that inserted them cannot be ordered reversely in $t$. More formally, let $k, k' \in O_t$ s.t. $n_s(k)-> ts \leq n_s(k')->ts$. Then, $k' \nless_t k$.
\item[\emph{TidOrder}] Order among the nodes inserted by the same threads in $s$ must be preserved among the operations that inserted them in $t$. Let $k, k' \in O_t$ s.t. $myTid_s(k) = myTid_s(k')$ and $n_s(k)->ts < n_s(k')->ts$. Then, $k <_t k'$.
\item[Frontiers] Every maximally closed or pending vertex can be removed by a pending pop. More formally, let $k \in O_t$ such that $\ell_t(k) = (\_,\texttt{PEND})$. Then, for all pops $p$, $k \in ov_t(p)$. In the other case, let $k \in O_t$ such that $\ell_t(k) = (\_,\texttt{COMP})$ and for all other $k' \in O_t$ such that $k<_t k'$, we know $\ell_t(k') = (\_,\texttt{PEND})$. Then, for all pop operations $p$, $k \in be_t(p)$ or $k \in ov_t(p)$. 
\item[\emph{MaximalOV}] If a push $k \in O_t$ is a candidate to be removed by a pop $p$, then every other push $k'$ invoked after $k$ is a candidate to be removed by $p$ since $k$ is concurrent with $p$. More formally, let $k, k' \in O_t$ such that $k <_t k'$ and there exists a pop $p$ such that $k \in be_t(p)$ or $k \in ov_t(p)$. Then, $k' \in ov_t(p)$.
\item[\emph{MinimalBE}] If a push $k \in O_t$ has finished before the pop $p$ is invoked and yet $k$ is a candidate to be removed by $p$, other pushes completed before $k$ can not be candidates to be removed by $p$ at that state. More formally, let $k, k' \in O_t$ such that $k <_t k'$ and there exists a pop $p$ such that $k' \in be_t(p)$. Then, neither $k \in be_t(p)$ nor $k \in ov_t(b)$.
\item[\emph{ReverseFrontiers}] If a push $k \in O_t$ is concurrent with the pop $p$ and there exists another push $k' \in O_t$ that is immediate predecessor of $k$, then $k'$ is either concurrent or maximally closed with respect to $p$. More formally, let $k, k' \in O_t$ such that $k' \in pred_{<_t}(k)$ and $k \in ov_t(p)$ for some pop $p$. Then, either $k' \in ov_t(p)$ or $k' \in be_t(p)$. 
\item[\emph{TraverseBefore}] If a pop operation $p$ is currently visiting node $n$ and there is a node $m$ coming before $n$ in the traverse order with a greater timestamp, then the operation that inserts $m$ must be concurrent with $p$. More formally, let $k \in O_t$ such that $n_s(k) <^{tr}_s n_s(p)$ and $n_s(k)->ts \geq n_s(p)->ts$. Then, $k \in ov_t(p)$.
\item[\emph{TraverseAfter}] If a pop operation $p$ is currently visiting node $n$ that is not null and its youngest element $m$ is not null and still not taken in state $s$, then either $m$ is a candidate to be removed by $p$ in $t$ or there exists a later node $m'$ than $n$ such that $m'$ is a candidate in $t$ and it has a bigger timestamp than n. More formally, assume that there exists $k, k' \in O_t$ such that $youngest_s(p)->taken \neq false$, $youngest_s(p) = n_s(k)$ and $n_s(k') = n_s(p)$. Then, either $k \in ov_t(p) \vee k \in be_t(p)$ or there exists $k'' \in O_t$ s.t. $n_s(k'')->ts > n_s(k) ->ts$ and $k'' \in ov_t(p) \vee k'' \in be_t(p)$ and either $k' <^{tr}_s k''$ or $n_s(p) = n_s(k'') \wedge cp_s(p) = R_j \wedge j>3$. 
\end{itemize}
Next, we will show that $fs$ is really a Com(pop)-forward simulation relation. Except the trivial base case, we case-split on the transition rules. We first assume $(s, \alpha s') \in \delta_C$ and $t \in fs[s]$. Then, we find  corresponding transition $\alpha' \in \Sigma_{AbsS}$ obeying the Com(pop)-forward simulation relation conditions and obtain $t'$ such that $(t, \alpha' t') \in \delta_{AbsS}$  and $t' \in fs[s']$.

We observe that if $\alpha \in C \cup R \cup Com(pop)$, then the corresponding rule in $AbsS$ is $\alpha' = \alpha$. Otherwise, $\alpha' = \epsilon$.

Let the following derivation rule of $TSS$ be the one for describing $\alpha$:
\begin{mathpar}
    \inferrule{
      \psi
    }{
      s
      \xrightarrow{\alpha} 
      s'
    }
\end{mathpar}
and the following one be the derivation rule of $AbsS$ describing $\alpha'$ if $\alpha' \neq \epsilon$ (equivalently $\alpha' = \alpha$):
\begin{mathpar}
    \inferrule{
      \psi'
    }{
      q
      \xrightarrow{\alpha'} 
      q'
    }
\end{mathpar}
For the cases $\alpha' = \alpha$, we first need to show $\alpha'$ is enabled in state $t$ i.e., $t$ satisfies $\psi'$. If this can not be directly obtained from $s$ satisfies $\psi$ and using one or two obvious conditions on $fs$ (since $t \in fs[s]$), we show the derivation in the proof. Then, $t'$ is obtained in a unique way since $AbsS$ is deterministic on its alphabet $ \Sigma_{AbsS} = C \cup R \cup Com(pop)$. The, only other thing to show is $t' \in fs[t']$. We show this by proving that $t'$ does not violate any of the conditions of the $fs$ described above. We only explain why the new instantiations due to the difference between $s'$ and $s$ or the difference between $t'$ and $t$ do not violate the conditions. We skip the instances that we assumed while relating $s$ to $t$.

For the cases in which $\alpha' = \epsilon$, we have $t'=t$ and the only thing to show is $t \in fs[s']$. Again, we only explain why the new instantions due to the difference between $s'$ and $s$ do not violate the conditions.
\begin{itemize}
\item[\textsc{call-push}] The same derivation rule of $TSS$ is applied to $t$ obtain $t'$. The premise of the rule is satisfied by $t$ trivially in the sense explained before. The new vertex $k$ is added to the $O_t$ such that $k$ is maximal, pending and every completed vertex is ordered before $k$ in $t'$. Moreover, $k$ is overlapping with every pending pop. To see that $t' \in fs[s']$ we observe the following: \emph{Nodes} condition is preserved because $k \in O_{t'}$. Since the newly added vertex $k$ is maximal and pending in $t'$, \emph{Pend/Comp} condition is preserved. \emph{Frontiers} and \emph{MaximalOV} conditions are not violated since $k$ is added to $ov(p)$ set for every pending pop operation $p$. 
\item[\textsc{push1}] We have $t' = t$ and show $t \in fs[s']$.\emph{Nodes} and \emph{Pend/Comp} conditions are still satisfied since $k$ remains to be a pending vertex. \emph{TSOrder} is still preserved. Timestamp of $n_{s'}(k)$ is maximal and every other nodes of push operations with maximal timestamp in $s'$ are pending vertices in $t$. Hence there can be no ordering between those pushes and $k$ in $t$ that can violate \emph{TSOrder}. Moreover, $k$ is maximal in $t$ which means that it cannot be ordered before another push $k'$ of which node has a lower timestamp. \emph{TidOrder} is also satisfied. Since $k$ is ordered after every completed push in $t$ and every other push by the same thread is completed, ordering required by the \emph{TidOrder} is present.
\item[\textsc{push2}] We have $t' = t$ and show $t \in fs[s']$. \emph{Nodes} and \emph{Pend/Comp} conditions are still satisfied since $k$ remains to be a pending vertex. One can also see that the \emph{TraverseBefore} condition is preserved. Let the pop $p$ visiting node $m$ and $n_{s'}(k) <^{tr}_{s'} m$. Since $k$ and $p$ are both pending in $s$ and $t \in fs[s]$, $k \in ov_t(p)$ (by the \emph{Frontiers} condition). Hence, \emph{TraverseBefore} is preserved. 
\item[\textsc{push3}] We have $t' = t$ and show $t \in fs[s']$. We consider two cases: $n_s(k)->taken$ is \texttt{true} or it is \texttt{false}. For the former case, $k \notin O_t$. The only new instantiation we check is $k \notin O_t$ does not violate \emph{Nodes} condition while relating $s'$ to $t$. For the latter case, we have $k \in O_t$. \emph{Nodes} and \emph{Pend/Comp} conditions are still satisfied since $k$ remains to be a pending vertex after changing $s$ to $s'$.
\item[\textsc{push4}] We have $t' = t$ and show $t \in fs[s']$. We consider two cases: $n_s(k)->taken$ is \texttt{true} or it is \texttt{false}. For the former case, \emph{Nodes} condition is still satisfied since $k$ remains to be not a vertex. For the latter case \emph{Nodes} and \emph{Pend/Comp} conditions are still satisfied since $k$ remains to be a pending vertex. \emph{TSOrder} condition is still not violated since if $k'<_t k$, then $k'$ is a completed vertex in $s$ and $s'$. By the premise of the rule (which can be shown to hold for every operation at control point $A_4$) $i_s(k') < i_s(k)$ and consequently $n_{s'}(k')->ts < n_{s'}(k)->ts$. Since every other push by the thread of $k$ is completed, \emph{TidOrder} still continues to hold for the same reasons. \emph{TraverseAfter} condition is also preserved. Let $k'$ be the push and $p$ be the pop such that $n_s(k') = youngest_s(p)$, $n_s(k') \leq^{tr}_s n_s(k)$, $n_s(k')->ts < n_s(k)->ts$ and $k \in ov_t(p)$ or $k \in be_t(p)$. Assume $n_{s'}(k')->ts \geq N_{s'}(k)->ts$ after the action. Then, $k'$ must be a pending push both in $s$ and $s'$ by the premise of the derivation rule and $k' \in ov_t(p)$ must be true by \emph{Frontiers} condition and $t \in fs[s]$. Hence, the \emph{TraverseAfter} condition is preserved.
\item[\textsc{ret-push}] We consider two cases, $n_s(k)->taken$ is \texttt{false} or \texttt{true}. For the former case, we obtain $t'$ by applying \textsc{ret-push1} rule of $AbsS$. \emph{Nodes} and \emph{Pend/Comp} conditions are still satisfied since $k$ becomes a completed vertex in $t'$. \emph{Frontiers} condition still holds since although $k$ become a maximally closed vertex in $t'$, we have $k \in ov_{t'}(p)$ for all pending nodes $p$ (due to \emph{Frontiers} condition, $t \in fs[s]$ and $k$ was a pending operation in state $t$, $k \in ov_t(p)$). 

For the latter case, we obtain $t'$ by applying \textsc{ret-push2} rule of $AbsS$. \emph{Nodes} condition is still satisfied since $k \notin O_{t'}$. 
\end{itemize}
\end{proof}

%\input{set}
\end{document}
