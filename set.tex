\section{Existence of Forward Simulations for Set Implementations That Have Fixed Remove Linearization Points }
For all the set libraries we fix $\mathcal{M} = \{ add, rmv, cnt\}$ where $rmv$ is short for remove and $cnt$ is short for contains methods and $\mathcal{D} = \{1, \texttt{TRUE}, \texttt{FALSE} \}$. We assume that only single element can be inserted into our list. Our results for this domain extends to other domains such as when $\mathcal{D} = \mathbb{N}$. We extend the definition of $A\Sigma$ introduced in Definition 2 for the set in our focus as $AS\Sigma = A\Sigma \cup \{lin(rmv,d,k)| d \in \{1\}, k \in \mathbb{N}\}$. We define s-refinement, s-linearizability and change the definitions of forward and backward simulations as in the beginning of Section 2.

We define $L_A$ as follows:
\begin{itemize}
\item $Q_A = 2^{\{1\}} \times (\mathbb{N} \rightarrow Lbl_A)$ where $Lbl_A = \{N, A_0, A_{1T}, A_{1F} A_2, R_0, R_{1T}, R_{1F}, R_2, C_0, C_{1T}, C_{1F}, C_2 \}$. For each $q \in Q_A$, $s_q$ represents the set component (first component), and $f_q$ represents the program counter (second component).
\item Transition labels consists of invocations, returns and linearizations of methods in $\mathcal{M}$: $\Sigma_A: AS\Sigma \cup \{lin(m,d,k)| m \in \{add,cnt\}, d\in \{1\}, k \in \mathbb{N} \}$. All methods return \texttt{TRUE} or \texttt{FALSE} and all take an element in $\{1\}$ as the input value.
\item ${q_0}_A = (\emptyset, f_{{q_0}_A}$ where $f_{{q_0}_A}(k) = N$ for all $k \in \mathbb{N}$.
\item State transitions:
\begin{itemize}
\item $(q, inv(add, d,k), q') \in \delta_A$ iff $d \in \{1\} \wedge f_q(k) = N \wedge f_{q'}(k) = A_0$
\item $(q, lin(add,d,k), q') \in \delta_A$ iff $d \in \{1\} \wedge f_q(k) = A_0 \wedge (d \in s_q \wedge s_q = s_{q'} \wedge f_{q'}(k) = A_{1F} \vee d \notin s_q \wedge s_{q'} = s_q \cup \{d\} \wedge f_{q'}(k) = A_{1T})$
\item $(q, ret(add,d,k) q') \in delta_A)$ iff $(f_q(k) = A_{1T} \wedge d = \texttt{TRUE} \vee f_q(k) = A_{1F} \wedge d = \texttt{FALSE}) \wedge f_{q'}(k) = A_2$
\item $(q, inv(rmv,d,k) q') \in \delta_A$ iff $d \in \{1\} \wedge f_q(k) = N \wedge f_{q'}(k)= R_0 $
\item $(q, lin(rmv,d,k), q') \in \delta_A$ iff $d \in \{1\} \wedge f_q(k) = R_0 \wedge (d \in s_q \wedge s_q = s_{q'} \cup \{d\} \wedge f_{q'}(k) = R_{1T} \vee d \notin s_q \wedge s_q = s_{q'} \wedge f_{q'}(k) = R_{1F} )$
\item $(q, ret(rmv,d,k) q') \in delta_A)$ iff $(f_q(k) = R_{1T} \wedge d = \texttt{TRUE} \vee f_q(k) = R_{1F} \wedge d = \texttt{FALSE}) \wedge f_{q'}(k) = R_2$
\item $(q, inv(cnt,d,k) q') \in \delta_A$ iff $d \in \{1\} \wedge f_q(k) = N \wedge f_{q'}(k)= C_0 $
\item $(q, lin(cnt,d,k), q') \in \delta_A$ iff $d \in \{1\} \wedge f_q(k) = C_0 \wedge s_q = s_{q'} \wedge (d \in s_q \wedge f_{q'}(k) = C_{1T} \vee d \notin s_q \wedge f_{q'}(k) = C_{1F} )$
\item $(q, ret(cnt,d,k) q') \in delta_A)$ iff $(f_q(k) = C_{1T} \wedge d = \texttt{TRUE} \vee f_q(k) = C_{1F} \wedge d = \texttt{FALSE}) \wedge f_{q'}(k) = C_2$
\end{itemize}
\end{itemize}

We define $L_I$ as follows:
\begin{itemize}
\item A state $q \in Q_I$ is a tuple of the form $(sac_q, src_q, UBSA_q, LBSA_q, CC_q, ubi,lbi, f_q)$ where $sac_q \in \mathbb{N}$ keeps the number of adds that return true so far, $src_q \in \mathbb{N}$ keeps the number of successful linearizations of remove (ones that move program counter from $R_0$ to $R_{1T}$), $f:\mathbb{N} \rightarrow Lbl_I$ is program counter that maps every operation to a label in $Lbl_I = \{N, A_0, A_1, R_0, R_{1T}, R_{1F}, R_2, C_0, C_1\}$. Let $PA_q = \{k \in \mathbb{N}| f_q(k) = A_0\}$ be the set of pending adds at state $q$. Then, $UBSA_q, LBSA_q: \mathbb{N} \rightarrow 2^{PE_q}$ are functions such that $UBSA_q(i)$ is a set of pending adds at most $i$ of which may return true and $LBSA_q(i)$ is a set of pending adds at least $i$ of which may return true. $ubi, lbi \in \mathbb{N}$ keeps the upper bound (lower bound) set indices that a new pending enqueue will be inserted to. Let $IC_q = \{k \in \mathbb{N}| f_q(k) = C_0 \vee f_q(k) = C_1$  be the set of contains operation identifiers. Then, $CC_q: IC_q \rightarrow 2^{PA}$ is a map that keeps a set of pending adds of which at least one should return true due to a true return of a contains operation.
\item Transition labels are exactly the abstract transition labels we have defined earlier: $\Sigma_I = AS\Sigma$
\item ${q_0}_I =(sac_{{q_0}_I}, src_{{q_0}_I}, UBSA_{{q_0}_I}, LBSA_{{q_0}_I}, CC_{{q_0}_I}, ubi_{{q_0}_I}, lbi_{{q_0}_I}, f_{{q_0}_I})$ where $sac_{{q_0}_I} = src_{{q_0}_I} =  0$, $lbi_{{q_0}_I} = ubi_{{q_0}_I} = 1$ and $f_{{q_0}_I}(k) = N$ for all $k \in \mathbb{N}$. Hence $PA_{{q_0}_I} = IC_{{q_0}_I} = \emptyset$ and $UBSA_{{q_0}_I}$, $LBSA_{{q_0}_I}$ and $CC_{{q_0}_I}$ are empty mappings.
\item Instead of giving state transition relation formally, I would like to explain how $UBSA$, $LBSA$ and $CC$ works by considering the possible state transformations (consider $q$ as pre-state and $q'$ as the post state as convention for the following):
\begin{itemize}
\item[$UBSA$] Initially, $ubi_{{q_0}_I} = 1$. Hence, a newly invoked add operation $a$ will be inserted into $UBSA_{{q_0}_I}(1)$. All the newly invoked operations are inserted to $UBSA_q(1)$ until a linearization of remove comes or one of the adds return successful. If the first case happens, we increment the index of every set by 1 i.e. $UBSA_{q'}(i) = UBSA_q(i-1)$ for all $i>0$ and $UBSA_{q'}(0) = \emptyset$. We also set $ubi_{q'} = 1$, if it was set to $0$ somehow before (Consider the trace $inv(add,a,1), ret(add,true,1), inv(add,a,2), lin(rmv,a,3)$. $ubi =0$ after second event and it needs to be incremented to $1$ after the fourth event). Next, consider the case of successful add. Let the operation identifier of the add that will return successful be $k$ and $i$ be the index such that $k \in UBSA_q(i)$. Then, for all $j > i$, $UBSA_{q'} (j-1) = UBSA_q(j)$, $UBSA_{q'}(i-1) = UBSA_q(i-1) \cup UBSA_q(i) \backslash \{ k\}$ and for all $j < i-1$, $UBSA_{q'}(j) = UBSA_q(j)$. We do not allow elements in $UBSA_q(0)$ to return true. So, $i=0$ cannot be true. If $i = 1$, we change $ubi_{q'} = 0$ to denote that no new coming add can return true from now on (consider the case: $inv(add,a,1), lin(rmv,a,2):true, inv(add,a,3), inv(add,a,4), lin(rmv,a,5):true, ret(add,true,3), ret(add,true,4), inv(add,a,6)$. This last invocation should be added to set with index $0$. So, we need to change $ubi$ to $0$ after last return. Lastly, a failing return of add simply removes this add from its set, without changing its index. Let $i$ be the index of the failing add operation $k$. Then, $UBSA_{q'}(i) = UBSA_q(i) \backslash \{k\}$. Observing a failing contains operation may change the upper bound. Consider the following trace: $inv(add,a,1), inv(add,a,2), inv(cnt,a,3), ret(cnt,false,3)$. Although $UBSA_{q'}(1) = \{1,2\}$ after the last event, none of $1$ or $2$ can return true due to the restrictions we impose on contains operations that we will explain later on.
\item[$LBSA$] Initially $lbi_{{q_0}_I} = 1$. When a new event of type invoke add comes, we modify $LBSA_{q'}(lbi_{q'}) = PE_{q'}$ where $lbi_{q'} = lbi_q$. Although it looks like that we build $LBSA_{q'}$ from scratch with every new add invocation, in practice, this is merely adding new pending add to the old set of the same index unless the $lbi$ field are the same. If a new successful linearization of remove comes, first it updates $LBSA_{q'}(lbi_q) = PE_{q'}$. Then, it increments the $lbi$ value by one if it was not $0$ before. If it was $0$ before, new $lbi$ value becomes $src_{q'} - sac_{q'}+1$. Note that a successful remove does not modify $LBSA$ field if a new add is invoked after the previous linearization of a successful remove. The first new add invocation that comes after a successful remove, copies the set $LBSA_{q}(lbi_q)$ and adds the new add's operation identifier as $LBSA_{q'}(lbi_{q'})$. However, if no new add comes between two successful remove linearizations, then $LBSA$ is modified by a sucsessful remove linearization. Next, consider the return events of add operations. First, consider the successful return. If an add operation with identifier $k$ returns true, we remove this identifier from the $LBSA$ sets of which $k$ is element of and decrement the index values of these sets by $1$. We can observe that if $k$ is the element of the set with index $i$ then it is element of every set with index $j>i$ \textcolor{red}{(We need to prove this)}. Hence we decrement the index of every set bigger than some $i$ value. For this case, we may end up with a situation that two sets fall into same index (at index $i-1$). In this case, one of the sets must be strictly subset of the other one \textcolor{red}{(We need to prove this)}. In this case, we keep the subset as the set of this index and delete the larger set. If $k$ is deleted from just no sets, we change $lbi_{q'} = 0$. To rationalize this behavior, consider the trace $inv(add,a,1), lin(rmv,a,2):true, inv(add,a,3), inv(add,a,4), lin(rmv,a,5):true, ret(add,true,3), ret(add,true,4), inv(add,a,6)$. The last add invocation should be put to the set with index $0$ and after the add with identifier $4$ returns true, our procedure makes $lbi_{q'} = 0$. If the removed element is in $LBSA_q(lbi_q) \backslash LBSA_q(lbi_q -1)$, then we also set $lbi_{q'} = 0$. The rationale behind this is the trace: $inv(add,a,1), lin(rmv,a,2):true, inv(add,a,3), ret(add,true,3), inv(add,a,4)$. The last operation with ID $4$ should be able to return false. If an add operation with identifier $k$ returns false, then we remove $k$ from all $LBSA$ sets that $k$ is element of. The constraint we check on $LBSA$ sets is that a return false event of an add operation keeps $|LBSA_{q'}(i)| \geq i$ for the indices $i$ it modified.
\item [$CC$] We need to keep a cc flag to show that now this operation may return true. It should be a map from identifiers to Boolean.
\end{itemize}
\end{itemize}
