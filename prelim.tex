\section{Preliminaries}
Systems we consider are labeled transition systems (LTS):
\begin{dfn}
An LTS is defined over four-tuples $A=(Q,\Sigma, q_0, \delta)$ where $Q$ is the set of states, $\Sigma$ is the set of transition labels, $q_0 \in Q$ is the initial state and $\delta \subseteq Q \times \Sigma \times Q$ is the transition relation.
\end{dfn}
Executions generated by this system are alternating sequence of states and transition labels $\rho = s_0, e_0, s_1,... s_k, e_k,...$ where each $s_i \in Q$, each $e_i \in \Sigma$, $s_0 = q_0$ and each $(s_i, e_i s_{i+1}) \in \delta$. The projection of the sequence $\rho$ over the set $\Pi$ is denoted by $\rho | \Pi$, and it is the maximum subsequence of $\rho$ consisting of elements of $\Pi$. Traces of the LTS are obtained from executions by projecting them over $\Sigma$. For the rest of the paper and in all of the proofs, we consider only finite executions (denoted as $E(A)$) and/or traces (denoted as $Tr(A)$ of the LTSs in focus.

Libraries are LTSs that provide methods. Let $\mathcal{M}$ be the set of method names and $\mathcal{D}$ be the domain of values as input/output parameters for the methods. Then, this library contains transition labels of the form $inv(m,d,i)$ representing the invocation of method $m \in \mathcal{M}$ with input value $d \in \mathcal{D}$. The third field is the operation identifier for differentiating the different calls of the same method from the set $\mathcal{O}$. For simplicity, we take $\mathcal{O} = \mathbb{N}$ for the rest of the paper. We also assume that methods could have at most one input parameter. If they do not have any input arguments (like pop method of a stack), we can omit the second field from the action. They also provide actions of the form $ret(m,d,i)$ representing the return of method $m \in M$ with value $d \in D$ which has been invoked previously with action $inv(m,d',i)$. Again, we assume that the methods can return at most one parameter and we may omit the second field from the action if they have none (like enqueue method of a queue). Before starting to reason about any set of libraries, we first fix the sets $\mathcal{M}$ and $\mathcal{D}$ and libraries in our focus agree on this sets. For any transition label $e = inv(m,d,i)$ or $e=ret(m,d,i)$, we have the function $oid(e) = i$.

Since libraries are LTSs, they produce traces. A trace $e = e_1, e_2, ..., e_n$ of library $L$ is \emph{well-formed} iff (i) every return matches an earlier invocation: $e_j = ret(m,d,k)$ implies that there exists $i<j$ such that $e_i = inv(m,d',k)$ and (ii) every operation identifier is used at most one invocation/return pair: $oid(e_i) = oid(e_j) = k$ and $i<j$ implies $e_i = inv(m,d,k)$ and $e_j = ret(m,d',k)$. From now on, we assume that libraries produce well-formed traces. Let $f: \mathbb{N} \rightarrow \mathbb(N)$ be a bijection. Then, traces $e$ and $e'$ are equivalent if $e'$ is obtained from $e$ by replacing every action $inv(m,d,k)$ with $inv(m,d,f(k))$ and every action $ret(m,d,k)$ with $ret(m,d,f(k))$. 

Based on these definitions on the traces of the libraries, we can define refinement between libraries:
\begin{dfn}
Let $L_1$ and $L_2$ be two libraries agreeing on $\mathcal{M}$ and $\mathcal{D}$ sets. We define the set $A\Sigma = \{inv(m,d,i)| m \in \mathcal{M} \wedge d \in \mathcal{D} \wedge i \in \mathbb{N}\} \cup \{ret(m,d,i)| m \in \mathcal{M}\wedge d \in \mathcal{D} \wedge i \in \mathbb{N}\}$ as abstract transition labels. Note that $A\Sigma \subseteq \Sigma_{L_1}$ and $A\Sigma \subseteq \Sigma_{L_2}$. Then, we say $L_1$ refines $L_2$ iff for every trace $e \in Tr(L_1)$, there exists a trace $e' \in Tr(L_2)$ such that $e|A\Sigma$ is equivalent to $e'|A\Sigma$.
\end{dfn}
Linearizability is also a relation between two libraries and it is stricter than refinement. It requires $e'$ in Definition 2 to be a sequential one. A trace $e$ is sequential iff following two conditions hold for its projection to abstract transition labels $e|A\Sigma = e_1, ...e_n$: $(i)$ $e_1 = inv(m,d,k)$ for some $m \in \mathcal{M}, d \in \mathcal{D} and k \in \mathbb{N}$ and $(ii)$ for all $i \in [1,n)$, either $e_i = inv(m,d,k)$ and $e_{i+1} = ret(m,d',k)$ or $e_i = ret(m,d,k)$ and $e_{i+1} = inv(m',d',k')$ for some $m,m' \in \mathcal{M}$, $d,d' \in \mathcal{D}$ and $k,k' \in \mathbb{N}$.

We can extend the relations between libraries by introducing simulation relations. We will later show that simulation relations imply refinement. 

\begin{dfn}
Let $L_1$ and $L_2$ be two libraries agreeing on $\mathcal{M}$ and $\mathcal{D}$ sets. Then, the relation $fs \subseteq Q_{L_1} \times Q_{L_2}$ is called a forward simulation iff the following holds:
\begin{itemize}
\item[(i)] $fs[q_{0_{L_1}}] = \{q_{0_{L_2}} \}$
\item[(ii-a)] If $(s,inv(m,d,k),s') \in \delta_{L_1}$ and $u \in fs[s]$, then there exists $u' \in fs[s']$ such that $u \xrightarrow{a} u'$ where $a = a_1, a_2, ..., a_n$ such that $a_1 = inv(m,d,k)$ and for all $i \in [2,n]$, $a_i \in \Sigma_{L_2} \backslash A\Sigma $. The expression $u \xrightarrow{a} u'$ means that there exists a sequence of states $u_1, u_2,...,u_{n+1}$ such that $u_1 = u$, $u_{n+1} = u'$ and for all $i \in [1,n]$, $(u_i, a_i, u_{i+1}) \in \delta_{L_2}$.
\item[(ii-b)] If $(s,ret(m,d,k),s') \in \delta_{L_1}$ and $u \in fs[s]$, then there exists $u' \in fs[s']$ such that $u \xrightarrow{a} u'$ where $a = a_1, a_2, ..., a_n$ such that $a_n = ret(m,d,k)$ and for all $i \in [1,n-1]$, $a_i \in \Sigma_{L_2} \backslash A\Sigma $. 
\item[(ii-c)] If $(s,t,s') \in \delta_{L_1}$ for some $t \in \Sigma_{L_1}\backslash A\Sigma$ and $u \in fs[s]$, then there exists $u' \in fs[s']$ such that $u \xrightarrow{a} u'$ where $a = a_1, a_2, ..., a_n$ such that for all $i \in [1,n]$, $a_i \in \Sigma_{L_2} \backslash A\Sigma $. Moreover, $a$ could be the empty sequence.
\end{itemize}
\end{dfn}
If $fs[s]$ is a unique state for all $s \in Q_{L_1}$ then it is called a refinement mapping/function. A dual notion of forward simulation is the backward simulation:
\begin{dfn}
Let $L_1$ and $L_2$ be two libraries agreeing on $\mathcal{M}$ and $\mathcal{D}$ sets. Then, the relation $bs \subseteq Q_{L_1} \times Q_{L_2}$ is called a backward simulation iff the following holds:
\begin{itemize}
\item[(i)] $bs[q_{0_{L_1}}] = \{q_{0_{L_2}} \}$
\item[(ii-a)] If $(s,inv(m,d,k),s') \in \delta_{L_1}$ and $u' \in bs[s']$, then there exists $u \in bs[s]$ such that $u \xrightarrow{a} u'$ where $a = a_1, a_2, ..., a_n$ such that $a_1 = inv(m,d,k)$ and for all $i \in [2,n]$, $a_i \in \Sigma_{L_2} \backslash A\Sigma $. 
\item[(ii-b)] If $(s,ret(m,d,k),s') \in \delta_{L_1}$ and $u' \in bs[s']$, then there exists $u \in bs[s]$ such that $u \xrightarrow{a} u'$ where $a = a_1, a_2, ..., a_n$ such that $a_n = ret(m,d,k)$ and for all $i \in [1,n-1]$, $a_i \in \Sigma_{L_2} \backslash A\Sigma $. 
\item[(ii-c)] If $(s,t,s') \in \delta_{L_1}$ for some $t \in \Sigma_{L_1}\backslash A\Sigma$ and $u' \in bs[s']$, then there exists $u \in bs[s]$ such that $u \xrightarrow{a} u'$ where $a = a_1, a_2, ..., a_n$ such that for all $i \in [1,n]$, $a_i \in \Sigma_{L_2} \backslash A\Sigma $. Moreover, $a$ could be the empty sequence.
\end{itemize}
\end{dfn}
Simulation relations are used to prove refinement relations among libraries. Following lemmas show their soundness:
\begin{lem}
Let $L_1$ and $L_2$ be two libraries agreeing on $\mathcal{M}$ and $\mathcal{D}$ sets. If $fs$ ($bs$) is a forward (backward) simulation relating $L_1$ to $L_2$, then $L_1$ refines $L_2$.
\end{lem}
\begin{proof}
Looks trivial and follows Lynch paper. Can be completed later.
\end{proof}