\section{Relaxation for the Data Structures Without Fixed Remove Linearization Points}
We have observed that some implementations (like time-stamped stack) do not have fixed remove (pop) linearization points that will correspond to $lin(pop,e,k)$ where $e$ could be a data value or $\texttt{EMPTY}$. However, we observe that, these implementations contain some points in their pop methods that logically removes the element from the pool. We call them commit points. If a method of a library has a fixed linearization  point, it is also a commit point. In this sense, commit points are weaker versions of fixed linearization points. Fixed linearization point of a pop preserves the following properties:
\begin{itemize}
\item If a $ret$ comes before a linearization point in the concrete execution, this order is preserved in the linearization of this execution.
\item If a $lin$ pop comes before another $lin$ pop in the concrete execution, this order is preserved in the linearization of this execution.
\item If a $lin$ pop comes before an $inv$ in the concrete execution, this order is preserved in the linearization of this execution. 
\end{itemize} 
A commit point is weaker than a fixed linearization point in the sense that it does not need to satisfy the first and the second conditions. 

To our intuition, if a pop (remove) method has multiple finite linearization points, commit point is the latest element in this set. We have never observed an implementation in which a pop is linearized after it logically removes the element from the data structure. 

From now on, we will restrict ourselves to stacks, since our example implementation that we will show linearizability of is the time-stamped (TS) stack. However, the notions and the machines we will introduce can be extended to queues easily. 

We fix $\mathcal{M} = \{push, pop\}$ and $\mathcal{D} = \mathbb{N} \cup \{\texttt{EMPTY}\}$. We extend the alphabet $A\Sigma$ for stacks with commit points as $ACS\Sigma = A\Sigma \cup \{com(pop,d,k)|d \in \mathcal{D}, k \in \mathcal{M}\}$. We define cs-refinement and cs-linearizability as we defined q-refinement, q-linearizability in the previous sections. We also change definitions of backward and forward simulation relations for stacks with commit points as we do in the previous sections by replacing linearization points with commit points in this extensions. Lemma 1 of the first section still holds with new simulation relation definitions and cs-linearizability and cs-linearizability implies the original linearizability definition. 

Our road map for this section is as follows: We will first introduce an intermediate stack machine $L_I$ that will be deterministic with respect to the alphabet $ACS\Sigma$. We will show that $L_I$ is equivalent to the standard abstract stack $L_A$ defined in the previous section with respect to the language $A\Sigma$. We show this by first showing that $L_I$ is a refinement of $L_A$ wrt alphabet $A\Sigma$ by finding a backward simulation relation between them and then $L_A$ is a refinement of $L_I$ with respect to alphabet $A\Sigma$ by finding a forward simulation relation between them. Since $L_I$ is deterministic wrt $ACS\Sigma$, if we have an implementation $L_C$ that is a cs-refinement of $L_I$, we can find a forward simulation between them. As an example, we will pick $L_C$ as time-stamped stack and establish a forward simulation relation between it and our $L_I$ machine. 

Let us continue with defining $L_I$ first:
\begin{itemize}
\item A state of $L_I$ again consists of a partial strict order and a program counter: $Q_I \subseteq ND \times ED \times (\mathbb{N} \rightarrow Lbl_I)$ where $Lbl_I = \{N, A_0, A_1, R_0, R_1, R_2\}$ is the set of transition labels for the operations. Different from the fixed linearization point case, this time nodes are not triples but 5-tuples of the form $(k,d,st,mc,con)$. First three fields are the same as previous intermediate machines: $k \in \mathbb{N}$ is operation identifier of a push operation, $d \in \mathcal{D}$ is the data value of that push and $st \in \{\texttt{PENDING}, \texttt{CLOSED}\}$ is the current status of the push operation. The fourth field $mc \subset \mathbb{N}$ keeps the operation identifiers of pop operations such that this push was maximally closed when the pop began. A node $n$ is maximally closed in a state $s$ iff $n.st  = \texttt{CLOSED}$ and if there is an edge $n \rightarrow n' \in ed_s$, then $n'.st = \texttt{OPEN}$. The fifth field $con \subset \mathbb{N}$ is the set of operation identifiers of the pop methods that are concurrent with this push i.e. the either this node was open when the pop started or this node is created when the pop was pending.
\item The transition labels consist of invocation and return actions of both methods and commit action for only pop method. Hence $\Sigma_I = ACS\Sigma$. Number of parameters for all actions common in previous intermediate stack machine and this intermediate stack machine are the same. Commit actions contain the second data field. They are of the form: $com(pop,d,k)$ where $d \in \mathcal{D}$ and $k \in \mathbb{N}$. 
\item Initial state consists of an empty strict partial order and a function mapping ever operation to $N$: ${q_0}_I = (\emptyset, \emptyset, f_{{q_0}_I})$ where  $f_{{q_0}_I}(i) =N$ for all $i \in \mathbb{N}$.
\item We define $\delta_I$ less formally, by giving verbal explanations to the transitions, omitting the obvious updates on the $f$ part and not mentioning about the parts of the nodes that does not change:
\begin{itemize}
\item $(q, inv(push,d,k),q') \in \delta_I$ iff a new node $n=(k,d,\texttt{PENDING}, \emptyset, con_n)$ is added to $nd_{q'}$, where $con_n = \{ i \in \mathbb{N}| f_q(i) = R_0\}$; $n' \rightarrow n$ will be added to $ed_{q'}$ if $n'$ is a closed node at the state $q$.
\item $(q, ret(push,k),q') \in \delta_I$ iff either there is a \texttt{PENDING} node $n$ in state $q$ and this node becomes \texttt{CLOSED} in state $q'$ or there is no node with identifier $k$ in $q$ and nothing else than $f$ field changes in $q'$.
\item $(q, inv(pop,k),q') \in \delta_I$ iff for every open node $n \in nd_q$, $k$ is added to $n.con$ in $q'$ and for every maximally closed node $m \in nd_q$, $k$ is added to $m.mc$ in state $q'$. 
\item $(q, com(pop,k,d), q') \in \delta_I$ iff there exists a node $n$ in state $q$ such that $n.d = d$ and either $k \in n.con$ or $k \in n.mc$, this node $n$ and all the nodes adjacent to it are removed in the state $q'$, $k$ is removed from all $con$ and $mc$ fields of all nodes in state $q'$ and for all other pop operations $k'$ in $n.mc$ or in $n.con$ and for all states $n' \in nd_q$ such that $n' \rightarrow n \in ed_q$ and for all $n'' \in nd_q$, $n' \rightarrow n'' \in ed_q$ implies $k' \in n''.con$ (implies $k \notin n''.mc$ but it is stronger than this condition: if there are three closed states $p,q,r$ s.t. $p \rightarrow q$, $q \rightarrow r$, $p \rightarrow r$, $k'$ is only in $r.mc$ and we delete $r$, former condition only allows $k' \in q.mc$ whereas the latter one allows $k' \in p.mc$ in addition) we have $k' \in n'.mc$ in the state $q'$. Note that we need to assume data independence to make this action deterministic.
\item $(q, ret(pop,k,d), q') \in \delta_I$ iff $q=q'$ ignoring the $f$ fields.
\end{itemize}
\end{itemize}
$L_A$ is the same machine defined in the previous section. The common alphabet between $L_A$ and $L_I$ is $A\Sigma$. We will show that they are equivalent in terms of this alphabet.

\begin{lem}
$L_I$ is a refinement of $L_A$.
\end{lem}
\begin{proof}
We will provide a backward simulation relation $bs$ between states of $L_I$ and states of $L_A$. Our relation $bs \subseteq Q_I \times Q_A$ relates state $q=(so_q, f_q)$ to $q' =(s_{q'}, f_{q'}$ iff (i) for all operation identifiers $k \in \mathbb{N}$, if $f_q(k) \in \{N,R_1,R_2\}$, then $f_q(k) = f_{q'}(k)$; if $f_q(k) = A_0$, then $f_{q'}(k) = A_0$ and the data value $d$ associated with this add operation is not inserted to $s_{q'}$ or $f_{q'}(k) = A_1$;  if $f_q(k) = A_1$, then $f_{q'}(k) = A_2$; if $f_q(k) = R_0$, then $f_{q'}(k)=R_0$ or $f_{q'}(k)=R_1$; (ii) Let us call a pop operation pending if $f_{q}(k) = R_0$ and $PP_q$ be set of pending pops. There there exists a function $g: PP_q \rightarrow ND_q \cup \{\texttt{NONE}\}$ such that $k \in g(k).mc$ or $k \in g(k).con$ for all pop operation identifiers $k$ such that $g(k) \neq \texttt{NONE}$ and $g$ is one-to-one if we neglect \texttt{NONE}; $s_{q'}$ is obtained by extending $so_q$ to a total order in which pending nodes may not take place and nodes (open or closed) $n$ such that there exists a pop operation with identifier $k$ so that $g(k)=n$ surely do not take place, (iii) $g(k) = \texttt{NONE}$ implies $f_{q'}(k) = R_0$ and $g(k) \neq \texttt{NONE}$ implies $f_{q'}(k) =R_1$, (iv) if $g_{q'}(k) =n$ and $n$ is a pending node, then $f_{q'}(k') = A_1$ where $k'$ is the operation identifier part of $n$, (v) if there is a pending node with identifier $k$ and it takes part in the linearization, then $f_{q'}(k) = A_1$. 

Now, we will show that $bs$ is a backward simulation relation:
\begin{itemize}
\item[$\langle i \rangle$] $bs[{q_0}_I] =\{{q_0}_A\}$
\item[$\langle ii-a-push \rangle$] Let $(q,inv(push,d,k),q') \in \delta_I$ and $t' \in bs[q']$. We consider two cases: Either the newly added node in $q'$ takes place in the linearization and there exists an index $i$ such that $s_{t'}(i) = d$ or this new node does not exist in the linearization. For the former case construct $s_t = \langle s_{t'}(1), s_{t'}(2),..., s_{t'}(i-1) \rangle$ and $f_t = f_{t'}$ for all the operations except the ones of which data values are linearized as $s_{t'}(j)$,  for $j\geq i$. For those nodes, $f_{t'}(k') = A_1$ whereas we assign $f_t(k') = A_0$ for $j>i$ and $f_t(k) = N$. Let operation identifiers of these nodes be $k_j$ for $j>i$. Then, $t \xrightarrow{\alpha} t'$ holds where $\alpha = inv(push,d,k), lin(push,d,k), lin(push,d_{i+1},k_{i+1}),....$. Moreover, $t \in bs[q]$ since $s_t$ is a valid linearization of $so_q$ using the same $g$ function and omitting more open nodes and $f_t$ obeys the conditions. For the latter case, we pick $s_t = s_{t'}$. We have two subcases:  There exists a pending pop with identifier $k'$ such that $g(k')$ is the new node with identifier $k$ or not. For the first subcase, we pick $f_t = f_{t'}$ except $f_t(k) = N$ and $f_t(k') = R_0$. Then $t xrightarrow{inv(push,d,k),lin(pop,d,k')} t'$ is a path in $L_A$ and $t \in bs[q]$. For the second subcase, we just pick $f_t = f_{t'}$ except $f_t(k) = N$. Then, it is easy to see that $t \xrightarrow{inv(push,d,k)} t'$ holds and $t \in bs[q]$. 
\item[$\langle ii-a-pop \rangle$] Let $(q, inv(pop,k),q') \in \delta_A$ and $t' \in bs[q']$. We will again consider two cases: When relating $t'$ to $q'$, either $g(k) = \texttt{NONE}$ or $g(k)$ is a node in $q'$. In other words, either the newly invoked pop operation $k$ did not linearize yet or it linearizes and removes an element inserted by a linearized push. The second case also splits into two cases: The element removed by pop $k$ is inserted by a push $k'$ that is still pending or the push has returned. We will look at all three cases separately. The easiest one is the first case. Construct $s_t=s_{t'}$ and $f_t = f_{t'}$ except that $f_t(k) = N$ whereas $f_{t'}(k)= R_0$. One can see that $t \xrightarrow{inv(pop,k)} t'$ is a step in $L_A$ and $t \in bs[q]$. For the first case of the second case, we construct $s_t = s_{t'} \circ \langle d \rangle$ where $d$ is the data of node identifier $k'$ and $f_t = f_{t'}$ except that $f_t(k) = N$ whereas $f_{t'}(k) = R_1$. One can see that $t \xrightarrow{inv(pop,k), lin(pop,d,k)}$ is a valid path in $L_A$. Moreover, $t \in bs[q]$ since $s_t$ is a valid linearization of $so_q$. This is true because the node with identifier $k'$ is a maximal node in $so_q$ and we can add it to the end of linearization of $so_{q'}$. For the second subcase, we obtain $s_t$   from $s_{t'}$ by the following procedure: Let $n$ be the node with identifier $k'$ and $k''$ be the node such that $k' \rightarrow k''$ is an edge in $so_{q'}$, $k''$ takes part in the linearization of $so_{q'}$ to $s_{t'}$ and it has the minimum index $i$ in the $s_{t'}$ among all such nodes. Then, $s_t = \langle s_{t'}(1), s_{t'}(2),..., s_{t'}(i-1), d \rangle$ where $d$ is the data value of node with identifier $k$. Let $k_j$ and $d_j$ be the identifiers and data values of nodes that constitute $s_{q'}(j)$ for $j>i$. Clearly, $t \xrightarrow{\alpha} t'$ is a path in $L_A$ where $\alpha = inv(pop,k), lin(pop,d,k), lin(push, d_i, k_i),...$. Moreover, $t \in bs[q]$ because $s_t$ is a valid linearization of $so_q$. It is true because $so_q = so_{q'}$, $k'$ is a maximally closed node in $so_q$ and all the nodes with identifier $k_j$ ($j>i$) are pending nodes.
\item[$\langle ii-c \rangle$] Let $(q, com(pop,d,k), q') \in \delta_I$ and $t' \in bs[q']$. We will consider two cases. The first case is commit action removes a maximally closed or an open node. For these cases, we can construct $t$ as in the second case of the previous item (invoke pop case). The same arguments apply for constructing a path between $t$ and $t'$ in $L_A$ and showing that $t \in bs[q]$.  The second case is that commit action removes a non-maximal closed node. This time, pick $t = t'$. Then, $t \xrightarrow{\epsilon} t'$ is the path in $L_A$ and one can show that $t \in bs[q]$ by choosing $g(k)$ as the node that is removed. 
\item[$\langle ii-b-push \rangle$] Let $(q,ret(push,k),q') \in \delta_I$ and $t' \in bs[q']$. We consider two cases. Either there is a node $n$ with identifier $k$ and data value $d$ in state $q$ or not. For the first case, we consider two subcases. Either this node takes part in linearization or not (if there exists a pop $k'$ such that $g(k')=n$). For the first subcase, we can pick $s_t = s_{t'}$ and $f_q = f_{q'}$ except that $f_q(k) = A_0$.  Then, $t \xrightarrow{ret(push,k)} t'$ is a path in $L_A$. Moreover, $t \in bs[q]$ since $n$ is a maximal node in $q$. For the second subcase, we pick $s_t = s_{t'} \circ \langle d \rangle$ and $f_t = f_{t'}$ except that $f_t(k) = A_1$ and $f_t(k') = R_0$. Then, $t \xrightarrow{lin(pop,d,k'), ret(push,k)} t'$ is a path $L_A$ and $t \in bs[q]$ since $n$ is a maximal open node in $q$. For the second case, we pick $s_t = s_{t'}$ and $f_t = f_{t'}$ except that $f_t(k) = A_1$. Then, $t \xrightarrow{ret(push,k)} t'$ is a path in $L_A$ and $t \in bs[q]$. 
\item[$\langle ii-b-pop \rangle$] Let $(q,ret(pop,d,k),q') \in \delta_I$ and $t' \in bs[q']$. We pick $s_t = s_{t'}$ and $f_t = f_{t'}$ except that $f_t(k) =R_1$. One can see that $t \xrightarrow{ret(pop,d,k)} t'$ is a valid action in $L_A$ and $t \in bs[q]$.
\end{itemize}
\end{proof}

\begin{lem}
$L_A$ is a refinement of $L_I$.
\end{lem}
\begin{proof}
We will construct a forward simulation relation $fs$ between $L_A$ and $L_I$. Our relation $fs \subseteq Q_A \times Q_I$ relates state $q = (s_q, f_q) \in Q_A$ to a state $q' =(so_{q'}, f_{q'}) \in Q_I$ iff (i) for all operation identifiers $k \in \mathbb{N}$, if $f_q(k) \in \{N, A_0, R_0, R_1, R_2\}$ then $f_{q'}(k) = f_q(k)$; if $f_q(k) = A_1$, then $f_{q'}(k) = A_0$; if $f_q(k) = A_2$, then $f_{q'}(k)= A_1$; (ii) We form nodes of $so_{q'}$ ($ND_{q'}$ as follows:  If $k$ is a push operation adding data value $d$ and either $f_q(k)= R_0$ or $f_q(k)=R_1$ and data added by this push exists in $s_q$, then there is a \texttt{PENDING} node in $ND_{q'}$ with identifier $k$ and data value $d$. If $f_q(k)= R_2$, then there is a \texttt{CLOSED} node in $nd_q$ with identifier $k$ and data value $d$. If there is an operation identifier $k$ such that $f_q(k) = R_0$, we call this a pending pop and this pop takes place $mc$ or $con$ fields of nodes of $q'$. If $n \in ND_{q'}$ is a \texttt{PENDING} node, then $k \in n.con$. If $n$ is maximally closed, then $k \in n.con$ or $n.mc$. If $k \in n.mc$ or $k \in n.con$ and there exists another node $n' \in ND_{q'}$ such that $n \rightarrow n' \in ED_{q'}$, then $k \in n'.con$. If $k \in n.mc$ and there exists another node $n' \in ND_{q'}$ such that $n' \rightarrow n \in ED_{q'}$, then neither $k \in n'.mc$ nor $k \in n'.con$. For any node $n \in ND_{q'}$, either $k \in n.mc$ or $k \in n.con$. (iii) We form edges of $so_{q'}$ ($ED_{q'}$) as follows: \texttt{PENDING} nodes are maximal. Edges obey the strict partial order conditions. (iv) We can find a linearization $so_{q'}$ that is equal to $s_q$. \texttt{PENDING} nodes may not participate in the linearization. Note that we do not need $g$ function for keeping track of linearized pops unlike the previous proof.

Next, we will show that $fs$ is a forward simulation relation.
\begin{itemize}
\item[$\langle i \rangle$] $fs[{q_0}_A] = \{{q_0}_I\}
$ 
\item[$\langle ii-a-push \rangle$] Let $(q, inv(push,d,k), q') \in \delta_A$ and $t \in fs[q]$. Pick $t'$ such that $(t, inv(push,d,k), t') \in \delta_I$. Since $s_q=s_{q'}$ and $so_{t'}$ contains a maximal open new node as the only difference from $so_t$, we can linearize $so_{t'}$ so that linearization is equal to $s_{q'}$. By checking the other conditions, one can observe that $t' \in fs[q']$.
\item[$\langle ii-a-pop \rangle$] Let $(q, inv(pop,k), q') \in \delta_A$ and $t \in fs[q]$. Pick $t'$ such that $(t, inv(pop,k), t') \in \delta_I$. Only difference between $t$ and $t'$ is that maximally closed and open nodes in $t'$ contain $k$ in their $mc$ or $con$ fields. Since this new addition obeys our forward simulation definition, $t' \in fs[q']$.
\item[$\langle ii-c-push \rangle$] Let $(q, lin(push,d,k) q') \in \delta_A$ and $t \in fs[q]$. Pick $t'=t$. $s_{q'}$ is still a linearization of $so_t$ since the node with identifier $k$ is a maximal node in $ND_t$ and we can linearize it at the end. So, $t' \in fs[q']$ holds.
\item[$\langle ii-c-pop \rangle$] Let $(q, lin(pop,d,k), q') \in \delta_A$ and $t \in fs[q]$. Pick $t'$ such that $(t, com(pop,d,k) t') \in \delta_I$. The action $com(pop,d,k)$ is a valid action in $L_I$ because $d$ is the last element in $s_q$. Hence, the node $n$ with identifier $k$ and data value $d$ is a maximal element in $so_q$ and either $k \in n.mc$ or $k \in n.con$ by the properties of $fs$. Hence, the node with identifier $k$ can be removed by a $com$ action. In addition, $s_{q'}$ is a linearization of $so_{t'}$ because removed node is a maximal node and $s_{q'}$ is obtained from $s_q$ by deleting the maximum node. Hence, $t' \in fs[q']$ holds.
\item[$\langle ii-b-push \rangle$] Let $(q, ret(push,k), q') \in \delta_A$ and $t \in fs[q]$. We will consider two cases: either the element inserted by the push with identifier $k$ is removed by a concurrent pop or the element is still in $s_q$. For the former case, there is no node with identifier $k$  in state $t$ and we can pick $t'$ such that $(t, ret(push,k), t') \in \delta_I$. We have $so_t = so_{t'}$ for this case. Since $s_q = s_{q'}$ also holds, $s_{t'}$ is a linearization of $so_{q'}$ and $t' \in fs[q']$. For the latter case, we again pick $t'$ such that $(t, ret(push,k), t') \in \delta_I$ holds. This time, only difference between $so_t$ and $so_{t'}$ is that the node with identifier $k$ is \texttt{CLOSED} in $so_{t'}$. Since the edges are the same, $s_{q'}$ is a valid linearization of $s_{t'}$ and $t' \in fs[q']$ holds. 
\item[$langle ii-b-pop \rangle$] Let $(q, ret(pop,d,k), q') \in \delta_A$ and $t \in fs[q]$. We pick $t'$ such that $(t, ret(pop,d,k) t') \in \delta_I$. Only difference between $t$ and $t'$ is that $f_{t'}(k) = R_2$ whereas $f_t(k) = R_1$. Since $s_q = s_{q'}$ and $so_t = so_{t'}$, $s_{q'}$ is a valid linearization of $so_{t'}$. By checking the other conditions, we see that $t' \in fs[q']$.  
\end{itemize}
\end{proof}

Now, we show that TS-Stack is linearizable by showing the concrete TS-Stack implementation $L_C$ is a cs-refinement of $L_I$. As $L_C$, we pick the simplest version that omits the \texttt{EMPTY} returns of the pop  methods, does not allow unlinking and elimination.