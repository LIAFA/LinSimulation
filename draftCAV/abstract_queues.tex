%!TEX root = draft.tex
\section{Abstract queues}

%\lstset{language={program}}

\begin{figure}[t]
\hspace{-8mm}
\begin{minipage}[t]{7.5cm}
\scriptsize{
{	%\centering
	\begin{align*}
%		& \mathsf{Operations}, \mathsf{Values} : \mathsf{Sort} \\
		& \text{\underline{Shared State}} \\
		& \text{{\ttfamily \bfseries function}}\ \mathsf{present} : \mathsf{Operations} \rightarrow \mathsf{Bool} \\
		& \text{{\ttfamily \bfseries function}}\ \mathsf{pending} : \mathsf{Operations} \rightarrow \mathsf{Bool} \\
		& \text{{\ttfamily \bfseries function}}\ \mathsf{arg} : \mathsf{Operations} \rightarrow \mathsf{Values} \\
		& \text{{\ttfamily \bfseries function}}\ \mathsf{before} : \mathsf{Operations} \times \mathsf{Operations} \rightarrow \mathsf{Bool} \\
%		& \mathsf{stored}, \mathsf{pending} : \mathsf{Operations} &\mbox{ // the status of an enqueue} \\
%		& \mathsf{arg} : \mathsf{Operations} \rightarrow \mathsf{Values} &\mbox{ // the argument of an enqueue} \\
	\end{align*}
}}
\end{minipage}
\begin{minipage}[t]{7.5cm}
\begin{lstlisting}
void enq($\mathsf{Values}$ x) {
  atomic rule inv(enq,x,k = new);
  atomic rule ret(enq,k);
}

$\mathsf{Values}$ deq() {
  atomic rule inv(deq,k = new);
  atomic rule lin(deq,y,k);
  atomic rule ret(deq,y,k);
}
\end{lstlisting}
\end{minipage}

\begin{minipage}[t]{7.5cm}
\begin{lstlisting}
rule inv(enq,x,k) = {
  $\mathsf{present}$(k) = true;
  $\mathsf{pending}$(k) = true;
  $\mathsf{arg}$(k) = x;
  forall k' with $\mathsf{present}$(k)$\land \neg \mathsf{pending}$(k') do
    $\mathsf{before}$(k',k) = true;
}

rule lin(deq,y,k) = {
  choose a $\in$ {true, false};
  if ((a || $\forall k.\ \mathsf{present}(k)$=false) && $\forall k.\ \mathsf{present}(k)\Rightarrow \mathsf{pending}(k)$) 
    y = EMPTY;
  else 
    choose k $\in$ $\mathsf{Operations}$ with $\mathsf{present}$(k)$\land\neg \exists k'.\ \mathsf{present}(k')\land \mathsf{before}(k',$k$)$;
    $\mathsf{present}$(k) = false;
    y = $\mathsf{arg}$(k);
}
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{5cm}
\vspace{-1mm}
\begin{lstlisting}
rule ret(enq,k) = {
  $\mathsf{pending}$(k) = false;
  return;
}
rule inv(deq,k) = {
  skip;
}
rule ret(deq,y,k) = {
  return y;
}
\end{lstlisting}
\end{minipage}
	\caption{The abstract queue implementation $AbsQ$.}
	\label{fig:signatures}
\end{figure}




\begin{figure}[t]
\scriptsize{
{	\centering
	\underline{Enqueue-Order Signature}
	\begin{align*}
%		& \mathsf{Operations}, \mathsf{Values} : \mathsf{Sort} \\
		& \text{{\ttfamily \bfseries function}}\ \mathsf{present} : \mathsf{Operations} \rightarrow \mathsf{Bool} &\mbox{ // the status of an enqueue} \\
		& \text{{\ttfamily \bfseries function}}\ \mathsf{pending} : \mathsf{Operations} \rightarrow \mathsf{Bool} &\mbox{ // the status of an enqueue} \\
		& \text{{\ttfamily \bfseries function}}\ \mathsf{arg} : \mathsf{Operations} \rightarrow \mathsf{Values} &\mbox{ // the argument of an enqueue} \\
		& \text{{\ttfamily \bfseries function}}\ \mathsf{before} : \mathsf{Operations} \times \mathsf{Operations} \rightarrow \mathsf{Bool} &\mbox{ // the happens-before order between enqueues} \\
%		& \mathsf{stored}, \mathsf{pending} : \mathsf{Operations} &\mbox{ // the status of an enqueue} \\
%		& \mathsf{arg} : \mathsf{Operations} \rightarrow \mathsf{Values} &\mbox{ // the argument of an enqueue} \\
	\end{align*}
}}

\begin{minipage}[t]{7.5cm}
\begin{lstlisting}
void enq($\mathsf{Values}$ x) {
  atomic rule inv(enq,x,k = new);
  atomic rule ret(enq,k);
}
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{5cm}
\begin{lstlisting}
$\mathsf{Values}$ deq() {
  atomic rule inv(deq,k = new);
  atomic rule lin(deq,y,k);
  atomic rule ret(deq,y,k);
}
\end{lstlisting}
\end{minipage}

\begin{minipage}[t]{7.5cm}
\begin{lstlisting}
rule inv(enq,x,k) = {
  $\mathsf{present}$(k) = true;
  $\mathsf{pending}$(k) = true;
  $\mathsf{arg}$(k) = x;
  forall k' with $\mathsf{present}$(k)$\land \neg \mathsf{pending}$(k') do
    $\mathsf{before}$(k',k) = true;
}

rule ret(enq,k) = {
  $\mathsf{pending}$(k) = false;
  return;
}
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{5cm}
\begin{lstlisting}
rule inv(deq,k) = {
  skip;
}

rule lin(deq,y,k) = {
  choose a $\in$ {true, false};
  if ((a || $\forall k.\ \mathsf{present}(k)$=false) && $\forall k.\ \mathsf{present}(k)\Rightarrow \mathsf{pending}(k)$) 
    y = EMPTY;
  else 
    choose k $\in$ $\mathsf{Operations}$ with $\mathsf{present}$(k)$\land\neg \exists k'.\ \mathsf{present}(k')\land \mathsf{before}(k',$k$)$;
    $\mathsf{present}$(k) = false;
    y = $\mathsf{arg}$(k);
}

rule ret(deq,y,k) = {
  return y;
}
\end{lstlisting}
\end{minipage}


%\begin{minipage}[t]{6cm}
%\begin{lstlisting}
%void enq($\mathsf{Values}$ x) {
% atomic {
%  k = *; 
%  assume $\neg \mathsf{stored}$(k);
%  $\mathsf{arg}$(k) = x;
%  $\mathsf{pending}$(k) = true;
%  $\mathsf{before}$ = $\mathsf{before}\cup\{(k',k)\,|\,\mathsf{stored}(k')\mbox{ and}$
%                     $\neg \mathsf{pending}(k')\}$  
% }
% atomic {
%  if ( $\mathsf{stored}$(k) )
%    $\mathsf{pending}$(k) = false;
% }
%}
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}[t]{5cm}
%\begin{lstlisting}
%$\mathsf{Values}$ deq() {
% if ( * )
%  atomic {
%   assume $\forall k.\ \mathsf{stored}(k)\Rightarrow \mathsf{pending}(k)$;
%   ret = EMPTY;
%  }
% else 
%  atomic {
%    k = *;
%    assume $\mathsf{stored}(k)\land \neg \exists k'.\ \mathsf{before}(k',k)$;
%    $\mathsf{stored}$(k) = false;
%    ret = $\mathsf{arg}$(k);
%  }
% return ret;
%}
%\end{lstlisting}
%\end{minipage}

	\caption{The abstract queue implementation $AbsQ$.}
	\label{fig:signatures}
\end{figure}
